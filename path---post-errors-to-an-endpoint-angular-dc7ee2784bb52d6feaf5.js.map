{"version":3,"sources":["webpack:///path---post-errors-to-an-endpoint-angular-dc7ee2784bb52d6feaf5.js","webpack:///./.cache/json/post-errors-to-an-endpoint-angular.json"],"names":["webpackJsonp","879","module","exports","data","post","id","html","htmlAst","type","children","tagName","properties","value","quirksMode","fields","slug","prefix","frontmatter","title","subTitle","cover","author","footnote","site","siteMetadata","facebook","appId","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,GAAA,yIAAAC,KAAA,spFAAqyFC,SAAiBC,KAAA,OAAAC,WAA2BD,KAAA,UAAAE,QAAA,IAAAC,cAA8CF,WAAcD,KAAA,OAAAI,MAAA,gLAAsMJ,KAAA,OAAAI,MAAA,OAA6BJ,KAAA,UAAAE,QAAA,IAAAC,cAA8CF,WAAcD,KAAA,OAAAI,MAAA,qNAA2OJ,KAAA,OAAAI,MAAA,OAA6BJ,KAAA,UAAAE,QAAA,KAAAC,cAA+CF,WAAcD,KAAA,OAAAI,MAAA,eAAqCJ,KAAA,UAAAE,QAAA,KAAAC,cAA+CF,WAAcD,KAAA,OAAAI,MAAA,0BAAgDJ,KAAA,OAAAI,MAAA,OAA6BJ,KAAA,UAAAE,QAAA,IAAAC,cAA8CF,WAAcD,KAAA,OAAAI,MAAA,8TAAoVJ,KAAA,OAAAI,MAAA,OAA6BJ,KAAA,UAAAE,QAAA,KAAAC,cAA+CF,WAAcD,KAAA,OAAAI,MAAA,uBAA6CJ,KAAA,OAAAI,MAAA,OAA6BJ,KAAA,UAAAE,QAAA,IAAAC,cAA8CF,WAAcD,KAAA,OAAAI,MAAA,wFAA8GJ,KAAA,OAAAI,MAAA,OAA6BJ,KAAA,UAAAE,QAAA,IAAAC,cAA8CF,WAAcD,KAAA,OAAAI,MAAA,0dAAgfJ,KAAA,OAAAI,MAAA,OAA6BJ,KAAA,UAAAE,QAAA,IAAAC,cAA8CF,WAAcD,KAAA,OAAAI,MAAA,4HAAkJJ,KAAA,OAAAI,MAAA,OAA6BJ,KAAA,UAAAE,QAAA,IAAAC,cAA8CF,WAAcD,KAAA,OAAAI,MAAA,+HAAqJJ,KAAA,OAAAI,MAAA,OAA6BJ,KAAA,UAAAE,QAAA,IAAAC,cAA8CF,WAAcD,KAAA,OAAAI,MAAA,kGAAwHJ,KAAA,OAAAI,MAAA,OAA6BJ,KAAA,UAAAE,QAAA,KAAAC,cAA+CF,WAAcD,KAAA,OAAAI,MAAA,qBAA2CJ,KAAA,OAAAI,MAAA,OAA6BJ,KAAA,UAAAE,QAAA,IAAAC,cAA8CF,WAAcD,KAAA,OAAAI,MAAA,sDAA4EJ,KAAA,OAAAI,MAAA,OAA6BJ,KAAA,UAAAE,QAAA,IAAAC,cAA8CF,WAAcD,KAAA,OAAAI,MAAA,24BAAi6BJ,KAAA,UAAAE,QAAA,KAAAC,cAA+CF,cAAiBD,KAAA,OAAAI,MAAA,YAAgCT,MAAUU,YAAA,IAAoBC,QAAWC,KAAA,uCAAAC,OAAA,cAAoEC,aAAgBC,MAAA,gDAAAC,SAAA,sJAAAC,MAAA,OAAuOC,QAAWhB,GAAA,2FAAAC,KAAA,oLAA0RgB,UAAajB,GAAA,6FAAAC,KAAA,wEAAgLiB,MAASC,cAAgBC,UAAYC,MAAA,OAAcC,aAAgBZ,KAAA","file":"path---post-errors-to-an-endpoint-angular-dc7ee2784bb52d6feaf5.js","sourcesContent":["webpackJsonp([198875604623637],{\n\n/***/ 879:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"post\":{\"id\":\"/Users/prasanna/projects/blog/content/posts/2016-06-25--post_errors_to_an_endpoint_angular/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>We were looking for an efficient way of capturing all the Javascript errors from browsers in our backend so it appears in our Kibana dashboard along with the server logs</p>\\n<p>We had a Angular 1.5.8 application in front of multiple micro-services endpoint. Any error in the angular application will appear in the browser console and we planned to push these logs back to the server.</p>\\n<h4>Angular’s <em>$exceptionHandler</em></h4>\\n<p>In order to catch all the exceptions, we have to override the $exceptionHandler component provided by angular. Only catch here is that, since we are overriding angular component we may not be able to inject $http or any other angular component in our overrides and doing so will throw a cyclic dependency issue.</p>\\n<h4>Initial solution</h4>\\n<p>We came up with an idea of injecting $injector and fetching $http using the same.</p>\\n<p>factory(‘$exceptionHandler’, [‘$log’, ‘$window’, ‘$injector’,\\n($log, $window, $injector)=> {\\nreturn (exception, cause) => {\\n$log.error(exception, cause);\\ntry {\\nconst $http = $injector.get(‘$http’);\\nconst logMessage = [{\\nlevel: ‘error’,\\nmessage: exception.toString(),\\nurl: $window.location.href,\\nstackTrace: exception.stack,\\ncurrentTimestamp: Date.now()\\n}];\\n$http.post(‘/log/message’, logMessage);\\n} catch (loggingError) {\\n$log.log(loggingError);\\n}\\n);</p>\\n<p>The above piece of code will work perfectly and will be able to post all the errors generated to an exposed endpoint.</p>\\n<p>But the problem is, if the $http.post throws any exception then it causes unrecoverable recursion and browser will hung.</p>\\n<p>In order to come out of that issue, we re wrote our http post logic using native JS syntax.</p>\\n<h4>Final solution</h4>\\n<p>Same code re written using native JS functions.</p>\\n<p>factory(‘$exceptionHandler’, [‘$log’, ‘$window’, ‘$injector’, ($log, $window, $injector)=> {\\nreturn (exception, cause) => {\\n$log.error(exception, cause);\\ntry {\\nlet commonHeaders = $injector.get(‘$http’).defaults.headers.common;\\nconst logMessage = [{\\nlevel: ‘error’,\\nmessage: exception.toString(),\\nurl: $window.location.href,\\nstackTrace: exception.stack,\\ncurrentTimestamp: Date.now()\\n}];\\nlet xmlhttp = new XMLHttpRequest();\\nxmlhttp.open(‘POST’, ‘/log/message’);\\nxmlhttp.setRequestHeader(‘Content-Type’, ‘application/json;charset=UTF-8’);\\nfor (let header in commonHeaders) {\\nif (commonHeaders.hasOwnProperty(header)) {\\nlet headerValue = commonHeaders[header];\\nif (angular.isFunction(headerValue)) {\\nheaderValue = headerValue();\\n}\\nxmlhttp.setRequestHeader(header, headerValue);\\n}\\n}\\nxmlhttp.send(angular.toJson(logMessage));\\n} catch (loggingError) {\\n$log.log(loggingError);\\n}\\n};<br>\\n});</p>\",\"htmlAst\":{\"type\":\"root\",\"children\":[{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"We were looking for an efficient way of capturing all the Javascript errors from browsers in our backend so it appears in our Kibana dashboard along with the server logs\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"We had a Angular 1.5.8 application in front of multiple micro-services endpoint. Any error in the angular application will appear in the browser console and we planned to push these logs back to the server.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"h4\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"Angular’s \"},{\"type\":\"element\",\"tagName\":\"em\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"$exceptionHandler\"}]}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"In order to catch all the exceptions, we have to override the $exceptionHandler component provided by angular. Only catch here is that, since we are overriding angular component we may not be able to inject $http or any other angular component in our overrides and doing so will throw a cyclic dependency issue.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"h4\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"Initial solution\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"We came up with an idea of injecting $injector and fetching $http using the same.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"factory(‘$exceptionHandler’, [‘$log’, ‘$window’, ‘$injector’,\\n($log, $window, $injector)=> {\\nreturn (exception, cause) => {\\n$log.error(exception, cause);\\ntry {\\nconst $http = $injector.get(‘$http’);\\nconst logMessage = [{\\nlevel: ‘error’,\\nmessage: exception.toString(),\\nurl: $window.location.href,\\nstackTrace: exception.stack,\\ncurrentTimestamp: Date.now()\\n}];\\n$http.post(‘/log/message’, logMessage);\\n} catch (loggingError) {\\n$log.log(loggingError);\\n}\\n);\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"The above piece of code will work perfectly and will be able to post all the errors generated to an exposed endpoint.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"But the problem is, if the $http.post throws any exception then it causes unrecoverable recursion and browser will hung.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"In order to come out of that issue, we re wrote our http post logic using native JS syntax.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"h4\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"Final solution\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"Same code re written using native JS functions.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"factory(‘$exceptionHandler’, [‘$log’, ‘$window’, ‘$injector’, ($log, $window, $injector)=> {\\nreturn (exception, cause) => {\\n$log.error(exception, cause);\\ntry {\\nlet commonHeaders = $injector.get(‘$http’).defaults.headers.common;\\nconst logMessage = [{\\nlevel: ‘error’,\\nmessage: exception.toString(),\\nurl: $window.location.href,\\nstackTrace: exception.stack,\\ncurrentTimestamp: Date.now()\\n}];\\nlet xmlhttp = new XMLHttpRequest();\\nxmlhttp.open(‘POST’, ‘/log/message’);\\nxmlhttp.setRequestHeader(‘Content-Type’, ‘application/json;charset=UTF-8’);\\nfor (let header in commonHeaders) {\\nif (commonHeaders.hasOwnProperty(header)) {\\nlet headerValue = commonHeaders[header];\\nif (angular.isFunction(headerValue)) {\\nheaderValue = headerValue();\\n}\\nxmlhttp.setRequestHeader(header, headerValue);\\n}\\n}\\nxmlhttp.send(angular.toJson(logMessage));\\n} catch (loggingError) {\\n$log.log(loggingError);\\n}\\n};\"},{\"type\":\"element\",\"tagName\":\"br\",\"properties\":{},\"children\":[]},{\"type\":\"text\",\"value\":\"\\n});\"}]}],\"data\":{\"quirksMode\":false}},\"fields\":{\"slug\":\"/post_errors_to_an_endpoint_angular/\",\"prefix\":\"2016-06-25\"},\"frontmatter\":{\"title\":\"Post browser logs to server in an Angular app\",\"subTitle\":\"This post describes about posting all the browser errors in an angular application to an endpoint. This will be helpful to analyse or debug issues.\",\"cover\":null}},\"author\":{\"id\":\"/Users/prasanna/projects/blog/content/parts/author.md absPath of file >>> MarkdownRemark\",\"html\":\"<p><strong>Prasanna</strong> is a full stack web developer, loves to build user interfaces with Javascript. Considers himself as a geek, quick learner and a team player 😃 </p>\"},\"footnote\":{\"id\":\"/Users/prasanna/projects/blog/content/parts/footnote.md absPath of file >>> MarkdownRemark\",\"html\":\"<ul>\\n<li>rants and writings through personal experience</li>\\n</ul>\"},\"site\":{\"siteMetadata\":{\"facebook\":{\"appId\":\"\"}}}},\"pathContext\":{\"slug\":\"/post_errors_to_an_endpoint_angular/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---post-errors-to-an-endpoint-angular-dc7ee2784bb52d6feaf5.js","module.exports = {\"data\":{\"post\":{\"id\":\"/Users/prasanna/projects/blog/content/posts/2016-06-25--post_errors_to_an_endpoint_angular/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>We were looking for an efficient way of capturing all the Javascript errors from browsers in our backend so it appears in our Kibana dashboard along with the server logs</p>\\n<p>We had a Angular 1.5.8 application in front of multiple micro-services endpoint. Any error in the angular application will appear in the browser console and we planned to push these logs back to the server.</p>\\n<h4>Angular’s <em>$exceptionHandler</em></h4>\\n<p>In order to catch all the exceptions, we have to override the $exceptionHandler component provided by angular. Only catch here is that, since we are overriding angular component we may not be able to inject $http or any other angular component in our overrides and doing so will throw a cyclic dependency issue.</p>\\n<h4>Initial solution</h4>\\n<p>We came up with an idea of injecting $injector and fetching $http using the same.</p>\\n<p>factory(‘$exceptionHandler’, [‘$log’, ‘$window’, ‘$injector’,\\n($log, $window, $injector)=> {\\nreturn (exception, cause) => {\\n$log.error(exception, cause);\\ntry {\\nconst $http = $injector.get(‘$http’);\\nconst logMessage = [{\\nlevel: ‘error’,\\nmessage: exception.toString(),\\nurl: $window.location.href,\\nstackTrace: exception.stack,\\ncurrentTimestamp: Date.now()\\n}];\\n$http.post(‘/log/message’, logMessage);\\n} catch (loggingError) {\\n$log.log(loggingError);\\n}\\n);</p>\\n<p>The above piece of code will work perfectly and will be able to post all the errors generated to an exposed endpoint.</p>\\n<p>But the problem is, if the $http.post throws any exception then it causes unrecoverable recursion and browser will hung.</p>\\n<p>In order to come out of that issue, we re wrote our http post logic using native JS syntax.</p>\\n<h4>Final solution</h4>\\n<p>Same code re written using native JS functions.</p>\\n<p>factory(‘$exceptionHandler’, [‘$log’, ‘$window’, ‘$injector’, ($log, $window, $injector)=> {\\nreturn (exception, cause) => {\\n$log.error(exception, cause);\\ntry {\\nlet commonHeaders = $injector.get(‘$http’).defaults.headers.common;\\nconst logMessage = [{\\nlevel: ‘error’,\\nmessage: exception.toString(),\\nurl: $window.location.href,\\nstackTrace: exception.stack,\\ncurrentTimestamp: Date.now()\\n}];\\nlet xmlhttp = new XMLHttpRequest();\\nxmlhttp.open(‘POST’, ‘/log/message’);\\nxmlhttp.setRequestHeader(‘Content-Type’, ‘application/json;charset=UTF-8’);\\nfor (let header in commonHeaders) {\\nif (commonHeaders.hasOwnProperty(header)) {\\nlet headerValue = commonHeaders[header];\\nif (angular.isFunction(headerValue)) {\\nheaderValue = headerValue();\\n}\\nxmlhttp.setRequestHeader(header, headerValue);\\n}\\n}\\nxmlhttp.send(angular.toJson(logMessage));\\n} catch (loggingError) {\\n$log.log(loggingError);\\n}\\n};<br>\\n});</p>\",\"htmlAst\":{\"type\":\"root\",\"children\":[{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"We were looking for an efficient way of capturing all the Javascript errors from browsers in our backend so it appears in our Kibana dashboard along with the server logs\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"We had a Angular 1.5.8 application in front of multiple micro-services endpoint. Any error in the angular application will appear in the browser console and we planned to push these logs back to the server.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"h4\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"Angular’s \"},{\"type\":\"element\",\"tagName\":\"em\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"$exceptionHandler\"}]}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"In order to catch all the exceptions, we have to override the $exceptionHandler component provided by angular. Only catch here is that, since we are overriding angular component we may not be able to inject $http or any other angular component in our overrides and doing so will throw a cyclic dependency issue.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"h4\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"Initial solution\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"We came up with an idea of injecting $injector and fetching $http using the same.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"factory(‘$exceptionHandler’, [‘$log’, ‘$window’, ‘$injector’,\\n($log, $window, $injector)=> {\\nreturn (exception, cause) => {\\n$log.error(exception, cause);\\ntry {\\nconst $http = $injector.get(‘$http’);\\nconst logMessage = [{\\nlevel: ‘error’,\\nmessage: exception.toString(),\\nurl: $window.location.href,\\nstackTrace: exception.stack,\\ncurrentTimestamp: Date.now()\\n}];\\n$http.post(‘/log/message’, logMessage);\\n} catch (loggingError) {\\n$log.log(loggingError);\\n}\\n);\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"The above piece of code will work perfectly and will be able to post all the errors generated to an exposed endpoint.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"But the problem is, if the $http.post throws any exception then it causes unrecoverable recursion and browser will hung.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"In order to come out of that issue, we re wrote our http post logic using native JS syntax.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"h4\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"Final solution\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"Same code re written using native JS functions.\"}]},{\"type\":\"text\",\"value\":\"\\n\"},{\"type\":\"element\",\"tagName\":\"p\",\"properties\":{},\"children\":[{\"type\":\"text\",\"value\":\"factory(‘$exceptionHandler’, [‘$log’, ‘$window’, ‘$injector’, ($log, $window, $injector)=> {\\nreturn (exception, cause) => {\\n$log.error(exception, cause);\\ntry {\\nlet commonHeaders = $injector.get(‘$http’).defaults.headers.common;\\nconst logMessage = [{\\nlevel: ‘error’,\\nmessage: exception.toString(),\\nurl: $window.location.href,\\nstackTrace: exception.stack,\\ncurrentTimestamp: Date.now()\\n}];\\nlet xmlhttp = new XMLHttpRequest();\\nxmlhttp.open(‘POST’, ‘/log/message’);\\nxmlhttp.setRequestHeader(‘Content-Type’, ‘application/json;charset=UTF-8’);\\nfor (let header in commonHeaders) {\\nif (commonHeaders.hasOwnProperty(header)) {\\nlet headerValue = commonHeaders[header];\\nif (angular.isFunction(headerValue)) {\\nheaderValue = headerValue();\\n}\\nxmlhttp.setRequestHeader(header, headerValue);\\n}\\n}\\nxmlhttp.send(angular.toJson(logMessage));\\n} catch (loggingError) {\\n$log.log(loggingError);\\n}\\n};\"},{\"type\":\"element\",\"tagName\":\"br\",\"properties\":{},\"children\":[]},{\"type\":\"text\",\"value\":\"\\n});\"}]}],\"data\":{\"quirksMode\":false}},\"fields\":{\"slug\":\"/post_errors_to_an_endpoint_angular/\",\"prefix\":\"2016-06-25\"},\"frontmatter\":{\"title\":\"Post browser logs to server in an Angular app\",\"subTitle\":\"This post describes about posting all the browser errors in an angular application to an endpoint. This will be helpful to analyse or debug issues.\",\"cover\":null}},\"author\":{\"id\":\"/Users/prasanna/projects/blog/content/parts/author.md absPath of file >>> MarkdownRemark\",\"html\":\"<p><strong>Prasanna</strong> is a full stack web developer, loves to build user interfaces with Javascript. Considers himself as a geek, quick learner and a team player 😃 </p>\"},\"footnote\":{\"id\":\"/Users/prasanna/projects/blog/content/parts/footnote.md absPath of file >>> MarkdownRemark\",\"html\":\"<ul>\\n<li>rants and writings through personal experience</li>\\n</ul>\"},\"site\":{\"siteMetadata\":{\"facebook\":{\"appId\":\"\"}}}},\"pathContext\":{\"slug\":\"/post_errors_to_an_endpoint_angular/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/post-errors-to-an-endpoint-angular.json\n// module id = 879\n// module chunks = 198875604623637"],"sourceRoot":""}