webpackJsonp([94417174589045],{873:function(e,t){e.exports={data:{post:{id:"/Users/prasanna/projects/blog-gatsby/content/posts/2014-06-27--making-https-call-using-apache-httpclient/index.md absPath of file >>> MarkdownRemark",html:'<p>This post details about making Secure HTTP(HTTPs) call from a server using Apache HTTPClient library.</p>\n<p>The simplest will be to ignore the ssl certificates and to trust any connection. This approach is not acceptable for production code as it defeat the purpose of using HTTPS. However in some use cases if you want to try out something quickly you can go with this route.</p>\n<h4>Trust any certificate approach (Simple, not recommended for production code.)</h4>\n<p>import javax.net.ssl.SSLContext;\nimport javax.net.ssl.X509TrustManager;</p>\n<p>import org.apache.http.client.HttpClient;\nimport org.apache.http.conn.ssl.SSLConnectionSocketFactory;\nimport org.apache.http.conn.ssl.SSLContexts;</p>\n<p>import org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;</p>\n<p>import java.security.SecureRandom;</p>\n<p>public class HttpClientFactory {</p>\n<div class="gatsby-highlight" data-language="text">\n      <pre class="language-text"><code class="language-text">private static CloseableHttpClient client;\n\npublic static HttpClient getHttpsClient() throws Exception {\n\n    if (client != null) {\n        return client;\n    }\n    SSLContext sslcontext = SSLContexts.custom().useSSL().build();\n    sslcontext.init(null, new X509TrustManager\\[\\]{new HttpsTrustManager()}, new SecureRandom());\n    SSLConnectionSocketFactory factory = new SSLConnectionSocketFactory(sslcontext,\n            SSLConnectionSocketFactory.BROWSER\\_COMPATIBLE\\_HOSTNAME\\_VERIFIER);\n    client = HttpClients.custom().setSSLSocketFactory(factory).build();\n\n    return client;\n}\n\npublic static void releaseInstance() {\n    client = null;\n}</code></pre>\n      </div>\n<p>}</p>\n<p>The above method will return httpClient object which can be used to make any HTTPS calls. Performing HTTPS call is no different from making HTTP call from now on. So you can have a factory with two methods, one for secure and one for non-secure.</p>\n<p>Here we have used HttpsTrustManager, which will do nothing more than trusing all clients. This is done by simply implementing X509TrustManager and auto generating all the methods.</p>\n<p>import java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;</p>\n<p>import javax.net.ssl.X509TrustManager;</p>\n<p>public class HttpsTrustManager implements X509TrustManager {</p>\n<div class="gatsby-highlight" data-language="text">\n      <pre class="language-text"><code class="language-text">@Override\npublic void checkClientTrusted(X509Certificate\\[\\] arg0, String arg1)\n\t\tthrows CertificateException {\n\t// TODO Auto-generated method stub\n\n}\n\n@Override\npublic void checkServerTrusted(X509Certificate\\[\\] arg0, String arg1)\n\t\tthrows CertificateException {\n\t// TODO Auto-generated method stub\n\n}\n\n@Override\npublic X509Certificate\\[\\] getAcceptedIssuers() {\n\treturn new X509Certificate\\[\\]{};\n}</code></pre>\n      </div>\n<p>}</p>\n<h4>Importing a keystore (Recommended)</h4>\n<p>If you are writing produciton quality code, then you should be looking at this approach. Have a all the keys in your application and create a SSLContext using those keystores. The created SSLContext can then be injected to SSLConnectionSocketFactory and remaining steps will be the same.</p>\n<p>import javax.net.ssl.SSLContext;</p>\n<p>import org.apache.http.client.HttpClient;\nimport org.apache.http.conn.ssl.SSLConnectionSocketFactory;\nimport org.apache.http.conn.ssl.SSLContexts;</p>\n<p>import org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.KeyManagementException;</p>\n<p>public class HttpClientFactory {</p>\n<div class="gatsby-highlight" data-language="text">\n      <pre class="language-text"><code class="language-text">private static CloseableHttpClient client;\n\npublic static HttpClient getHttpsClient() throws Exception {\n\n    if (client != null) {\n        return client;\n    }\n    SSLContext sslcontext = getSSLContext();\n    SSLConnectionSocketFactory factory = new SSLConnectionSocketFactory(sslcontext,\n            SSLConnectionSocketFactory.BROWSER\\_COMPATIBLE\\_HOSTNAME\\_VERIFIER);\n    client = HttpClients.custom().setSSLSocketFactory(factory).build();\n\n    return client;\n}\n\npublic static void releaseInstance() {\n    client = null;\n}\n\nprivate SSLContext getSSLContext() throws KeyStoreException, \nNoSuchAlgorithmException, CertificateException, IOException, KeyManagementException {\n    KeyStore trustStore  = KeyStore.getInstance(KeyStore.getDefaultType());\n    FileInputStream instream = new FileInputStream(new File(&quot;my.keystore&quot;));\n    try {\n        trustStore.load(instream, &quot;nopassword&quot;.toCharArray());\n    } finally {\n        instream.close();\n    }\n    return SSLContexts.custom()\n            .loadTrustMaterial(trustStore)\n            .build();\n}</code></pre>\n      </div>\n<p>}</p>\n<p>The only difference between the two approaches are the way the SSLContext been created.</p>',htmlAst:{type:"root",children:[{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"This post details about making Secure HTTP(HTTPs) call from a server using Apache HTTPClient library."}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"The simplest will be to ignore the ssl certificates and to trust any connection. This approach is not acceptable for production code as it defeat the purpose of using HTTPS. However in some use cases if you want to try out something quickly you can go with this route."}]},{type:"text",value:"\n"},{type:"element",tagName:"h4",properties:{},children:[{type:"text",value:"Trust any certificate approach (Simple, not recommended for production code.)"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"import javax.net.ssl.SSLContext;\nimport javax.net.ssl.X509TrustManager;"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"import org.apache.http.client.HttpClient;\nimport org.apache.http.conn.ssl.SSLConnectionSocketFactory;\nimport org.apache.http.conn.ssl.SSLContexts;"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"import org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"import java.security.SecureRandom;"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"public class HttpClientFactory {"}]},{type:"text",value:"\n"},{type:"element",tagName:"div",properties:{className:["gatsby-highlight"],dataLanguage:"text"},children:[{type:"text",value:"\n      "},{type:"element",tagName:"pre",properties:{className:["language-text"]},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"private static CloseableHttpClient client;\n\npublic static HttpClient getHttpsClient() throws Exception {\n\n    if (client != null) {\n        return client;\n    }\n    SSLContext sslcontext = SSLContexts.custom().useSSL().build();\n    sslcontext.init(null, new X509TrustManager\\[\\]{new HttpsTrustManager()}, new SecureRandom());\n    SSLConnectionSocketFactory factory = new SSLConnectionSocketFactory(sslcontext,\n            SSLConnectionSocketFactory.BROWSER\\_COMPATIBLE\\_HOSTNAME\\_VERIFIER);\n    client = HttpClients.custom().setSSLSocketFactory(factory).build();\n\n    return client;\n}\n\npublic static void releaseInstance() {\n    client = null;\n}"}]}]},{type:"text",value:"\n      "}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"}"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"The above method will return httpClient object which can be used to make any HTTPS calls. Performing HTTPS call is no different from making HTTP call from now on. So you can have a factory with two methods, one for secure and one for non-secure."}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"Here we have used HttpsTrustManager, which will do nothing more than trusing all clients. This is done by simply implementing X509TrustManager and auto generating all the methods."}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"import java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"import javax.net.ssl.X509TrustManager;"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"public class HttpsTrustManager implements X509TrustManager {"}]},{type:"text",value:"\n"},{type:"element",tagName:"div",properties:{className:["gatsby-highlight"],dataLanguage:"text"},children:[{type:"text",value:"\n      "},{type:"element",tagName:"pre",properties:{className:["language-text"]},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"@Override\npublic void checkClientTrusted(X509Certificate\\[\\] arg0, String arg1)\n\t\tthrows CertificateException {\n\t// TODO Auto-generated method stub\n\n}\n\n@Override\npublic void checkServerTrusted(X509Certificate\\[\\] arg0, String arg1)\n\t\tthrows CertificateException {\n\t// TODO Auto-generated method stub\n\n}\n\n@Override\npublic X509Certificate\\[\\] getAcceptedIssuers() {\n\treturn new X509Certificate\\[\\]{};\n}"}]}]},{type:"text",value:"\n      "}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"}"}]},{type:"text",value:"\n"},{type:"element",tagName:"h4",properties:{},children:[{type:"text",value:"Importing a keystore (Recommended)"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"If you are writing produciton quality code, then you should be looking at this approach. Have a all the keys in your application and create a SSLContext using those keystores. The created SSLContext can then be injected to SSLConnectionSocketFactory and remaining steps will be the same."}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"import javax.net.ssl.SSLContext;"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"import org.apache.http.client.HttpClient;\nimport org.apache.http.conn.ssl.SSLConnectionSocketFactory;\nimport org.apache.http.conn.ssl.SSLContexts;"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"import org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.KeyManagementException;"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"public class HttpClientFactory {"}]},{type:"text",value:"\n"},{type:"element",tagName:"div",properties:{className:["gatsby-highlight"],dataLanguage:"text"},children:[{type:"text",value:"\n      "},{type:"element",tagName:"pre",properties:{className:["language-text"]},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:'private static CloseableHttpClient client;\n\npublic static HttpClient getHttpsClient() throws Exception {\n\n    if (client != null) {\n        return client;\n    }\n    SSLContext sslcontext = getSSLContext();\n    SSLConnectionSocketFactory factory = new SSLConnectionSocketFactory(sslcontext,\n            SSLConnectionSocketFactory.BROWSER\\_COMPATIBLE\\_HOSTNAME\\_VERIFIER);\n    client = HttpClients.custom().setSSLSocketFactory(factory).build();\n\n    return client;\n}\n\npublic static void releaseInstance() {\n    client = null;\n}\n\nprivate SSLContext getSSLContext() throws KeyStoreException, \nNoSuchAlgorithmException, CertificateException, IOException, KeyManagementException {\n    KeyStore trustStore  = KeyStore.getInstance(KeyStore.getDefaultType());\n    FileInputStream instream = new FileInputStream(new File("my.keystore"));\n    try {\n        trustStore.load(instream, "nopassword".toCharArray());\n    } finally {\n        instream.close();\n    }\n    return SSLContexts.custom()\n            .loadTrustMaterial(trustStore)\n            .build();\n}'}]}]},{type:"text",value:"\n      "}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"}"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"The only difference between the two approaches are the way the SSLContext been created."}]}],data:{quirksMode:!1}},fields:{slug:"/making-https-call-using-apache-httpclient/",prefix:"2014-06-27"},frontmatter:{title:"Making HTTPS call using Apache HttpClient.",subTitle:"Perform Https calls from server using Apache HttpClient library.",cover:null}},author:{id:"/Users/prasanna/projects/blog-gatsby/content/parts/author.md absPath of file >>> MarkdownRemark",html:"<p><strong>Prasanna</strong> is a full stack web developer, loves to build user interfaces with Javascript. Considers himself as a geek, quick learner and a team player 😃 </p>"},footnote:{id:"/Users/prasanna/projects/blog-gatsby/content/parts/footnote.md absPath of file >>> MarkdownRemark",html:"<ul>\n<li>rants and writings through personal experience</li>\n</ul>"},site:{siteMetadata:{facebook:{appId:"670156599751120"}}}},pathContext:{slug:"/making-https-call-using-apache-httpclient/"}}}});
//# sourceMappingURL=path---making-https-call-using-apache-httpclient-e0549e88f0842af89e65.js.map